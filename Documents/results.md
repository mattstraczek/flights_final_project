## CS 225 Final Report

## Breadth First Search
  - Output/highlight part of the full scale run
    - Our breadth first search algorithm takes two parameters, a start and end airport. The algorithm has a vector of booleans to keep track of the airports that have been visited. It starts by adding an iterator for the list corresponding to the start airport in the adjacency list to a queue, and sets the current airport as visited. The function then enters a while loop that runs until the queue is empty or we have reached the end airport. Inside the loop, we start by initializing two list iterators, both of which are the element at the front of the queue, and pop from the queue. We then check that the distance of the current RouteEdge in the list is not zero, meaning that the current airport is a destination in this list (rather than the zero distance departure). If this is true, we access this airport’s index in the adjacency list, and set the iterator to the beginning of the list at this index, and add the airport to the pathMap, which maps the new airport to the previous airport. We then check to see if the current airport is the end airport, and if it is, we add this end airport to a path vector. We then go through the airports in the pathMap and add them to our path vector, working backwards until we reach the start airport, at which point we push the start airport to the path vector. Because we worked from end to start, we then reverse the path vector and return it. Path is a vector that represents the airports in the shortest path between the start and end, inclusive, in the order they are visited. However, if the if statement is false and we have not found the end airport, we iterate through the current list of RouteEdges and add iterators to the lists at their corresponding indices to the queue, if they have not been visited, and go to the beginning of the while loop checking if the queue is empty. If the queue is empty and we still have not found the end, it means the start and end are not connected and so we return an empty vector. This text file ![image](https://github-dev.cs.illinois.edu/cs225-sp22/lboelke2-aosepek2-junryuf2-mstrac4/blob/main/tests/bfs1_output.txt) shows the airports in the output vector of running BFS with ORD as the start and NOU as the end. This means that we start at ORD, fly to NRT, and then fly to NOU, and this is the least number of flights between the start and end airports. We also plot this path on a geographic map, making it easier to visualize the path that results from the BFS traversal. This picture is the plot of the BFS output with ORD as the start and NOU as the end, which follows the text output 
![image](https://github-dev.cs.illinois.edu/cs225-sp22/lboelke2-aosepek2-junryuf2-mstrac4/blob/main/tests/bfs3.png). 
  - Tests ran to verify the validity of the algorithm
    - For our BFS algorithm, we used multiple test cases to ensure that our code was functioning as intended. One of the cases we tested for was if the start or end airports did not exist. At the beginning of the algorithm, the function checks that the provided airports are in the airport map, and if they are not, it prints a statement saying they do not exist and returns an empty vector. We wrote a test case for this by requiring that the size of the returned vector is zero, and it passed. We also made sure our code could handle the case where the start and end airports were the same. The algorithm has if statements checking if the airport IDs are the same, and if the geographical coordinates are the same. In both cases, it returns an empty vector, which we test in our test cases, which passed. Another test we had tested if the graph could handle unconnected components of the graph. In the BFS algorithm, if the queue is empty and we still have not reached the end airport, an empty vector is returned. We tested for this by running BFS with an end airport that we knew was unreachable from the start airport, and made sure the output vector had a size of zero, and this test passed. We also tested that two connected airports returned a size greater than zero, which also passed. A final test we ran made sure that BFS did in fact find the shortest path, by finding two airports that had multiple paths between them, and then checking that the shortest path was the output, and checking that there was not a direct flight between them.

  - **A Visualization of BFS:**
    - **Note: BFS selects the minimal number of transfers between two airports**
      - Although the airports are near each other geographically, BFS selects the most efficient route with regard only to the number of transfers between the start and end airports: 
      - ![image](https://github-dev.cs.illinois.edu/cs225-sp22/lboelke2-aosepek2-junryuf2-mstrac4/blob/main/tests/BFSeval.png)

## Geographic Map Graphical Output:
  - For our geographic map algorithm, our goal was to visualize the routes made by our other algorithms, BFS and Prim’s. We decided to use the mercator projection of the World for our  graphical output. One challenge we faced when building our geographical output algorithm was accounting for the curvature of the Earth. Consequently, we incorporated a helper function in our graph class, drawLine(), which takes a given route and returns a path vector. The path vector represents a curved line between two given airports. In testing our geographical output algorithm, we used the assistance of google maps to compare the image of routes over the globe. 
  - **An example solution route from Google Maps included in our tests directory that will be used to compare against one produced by our geographical output algorithm:**
  - ![image](https://github-dev.cs.illinois.edu/cs225-sp22/lboelke2-aosepek2-junryuf2-mstrac4/blob/main/GeographicSoln.png) 
  - **A Visualization of all Global Routes Outputted by Geographical Algorithm:** 
  - ![image](https://github-dev.cs.illinois.edu/cs225-sp22/lboelke2-aosepek2-junryuf2-mstrac4/blob/main/geographic_map_ALLROUTES.png) 



## Prim’s Algorithm
  - The output of our Prim's Algorithm returns a vector of airports included in the minimum spanning tree. The return vector is structured where each element of the vector is a    pair, where the pair's first index is a boolean and the pair's second index is a string. The boolean component of the pair is labeled true if the airport is included in the      minimum spanning tree, false otherwise. Through our test cases, we were able to verify the correctness of our Prim's algorithm. In our test cases, we checked that our            algorithm always selected the minimum edge available. Since our function asks for a start airport, we also tested to see that the start airport was a valid airport within the    graph. Finally, we checked to see if the route data passed to our prim's function was structured correctly. In order for airport A to reach airport B, the route “R1: A -> B”    needs to be passed. On the contrary, if the route “R2: B -> A” was read from our routes list. Airport A would be unable to reach airport B even though both airports are          included in the route data. Through our geographical output function, we were able to see the correctness of our Prim's algorithm. Our graph output algorithm aided us in        debugging our Prim's algorithm as we could visually see unconnected airports. Through this visualization, we were able to see that not all airports were globally connected.      Consequently, domestic airports unconnected from the international graph were not included in our minimum spanning tree. In our first visualization below, the airports are      only connected domestically, so the global MST fails to include them. When the start airport is specified to one of the unconnected airports, the MST is unable to extend        globally, because none of the airports are connected internationally. 
  - **Visualization of Unconnected Airports:** 
  - ![image](https://github-dev.cs.illinois.edu/cs225-sp22/lboelke2-aosepek2-junryuf2-mstrac4/blob/main/Unconnected.png)
  - **Visualization of MST Outputted by Prim’s:**
  - ![image](https://github-dev.cs.illinois.edu/cs225-sp22/lboelke2-aosepek2-junryuf2-mstrac4/blob/main/mst_output.png)

## Concluding Thoughts:
  - We successfully answered our leading question. When we began our project, our main goal was to simulate the operation of an airline. We desired to create an airline that would connect all airports across the globe as efficiently as possible.  We used the BFS algorithm to find the least amount of transfers between two airports. We used Prim's algorithm to find the minimum number of routes needed to connect every airport in the world, while ensuring that the total distance of all routes was also minimized. When doing this, however, we discovered something that we found very interesting: although we had 3241 airports in our adjacency list, there were only 3190 routes in the minimum spanning tree. This meant that there were roughly fifty airports that were not included in the minimum spanning tree when we ran Prim’s algorithm starting from major airports, such as O’Hare. After discussing possible reasons for this, we came to the conclusion that the reason that these airports were not connected was because they were purely domestic flights. They were only connected to each other, making them unreachable from other airports in the world. We were able to prove this by focusing on a cluster of these graphs on the island of New Caledonia. We ran Prim’s algorithm starting from one of these unconnected airports, and the minimum spanning tree that was produced included only the other airports in New Caledonia.
## Link to Results Written Report (Google Docs):
  - https://docs.google.com/document/d/1k62TsFhNNjGs5AQkMXCKsqBkoqhLATMZ7sopfZQqaW4/edit?usp=sharing
  - 
